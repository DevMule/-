#include <iostream> //подключение библиотеки потокового ввода вывода
#include <thread> // подключение библиотеки для использования потоков
#include <mutex> // подключение библиотеки для регулирования критических зон
#include <chrono> // подключение библиотеки отсчета времени
#include <queue> // использование контейнера queue

using namespace std; // использование пространства имен std

mutex mt; // задание переменной типа mutex

void write(queue<int> &buf, int speed) // функция записи; принимает буфер и скорость
{
	while(true) // бесконечный цикл
	{
		this_thread::sleep_for(chrono::seconds(speed)); // регулирует скорость потока
		srand(time(0)); // сбрасывает сид для генератора случайных чисел
		if (buf.size() < 10) // если длина буфера меньше 10, то пишем в него
		{
			int message = rand() % 100; // получаем сообщение генератором случайных чисел
			mt.lock(); // блокируем доступ к критической секции
			buf.push(message); // пишем в конец очереди сообщение
			mt.unlock(); // разблокируем доступ к критической секции
			cout << "thread id:" << this_thread::get_id() << " message: " << message << endl; // вывод сообщения в консоль с id потока и сообщением, которое он записал
		}
		
	}
}

void read(queue<int> &buf, int speed) // функция чтения; принимает буфер и скорость
{
	while(true) // бесокнечный цикл
	{
		this_thread::sleep_for(chrono::seconds(speed)); // регулирует скорость работы
		if(buf.size() != 0) // если в буфере есть сообщения, читаем их
		{
			mt.lock(); // блокируем доступ к критической секции
			while (buf.size() != 0)
			{
				cout << "Thread: " << this_thread::get_id() << " Received message:" << buf.front() << endl; // вывод сообщения в консоль с id потока и сообщением, которое он получил
				buf.pop(); // удаляем считанное сообщение
			}
			mt.unlock(); // разблокируем доступ к критической секции
		}
	}
}

int main() // основной поток
{
	queue<int> buffer; // объявляем буфер, который может содержать только int
	thread writer1(write, ref(buffer), 3); // создаем первый поток писателя
	thread writer2(write, ref(buffer), 2); // создаем второй поток писателя
	thread reader(read, ref(buffer), 1); // создаем поток читателя
	writer1.join(); // ожидание завершения работы потока
	writer2.join(); // ожидание завершения работы потока
	reader.join(); // ожидание завершения работы потока
	return 0; // программа успешно завершилась, возвращаем 0 в качестве сигнала об этом
}